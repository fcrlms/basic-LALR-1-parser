from classes import RuleGroupClass, RuleClass

# returns list of terminals and nonterminals symbols
def parseSymbols (grammarDescription: dict) -> tuple:
	terminals = []
	nonterminals = []

	# every symbol that produces a rule is a nonterminal
	for k in grammarDescription:
		nonterminals.append(k)

	# if a symbol is in a production and isn't nonterminal
	# then it is terminal
	for productionList in grammarDescription.values():
		for prod in productionList:
			for symbol in prod:
				if symbol in nonterminals:
					continue

				if symbol not in terminals:
					terminals.append(symbol)

	return ( terminals, nonterminals )

# checks if grammar contains valid S0 starting rule
# S0 cannot be generated by anyone
# todo: check for infinite loops in grammar
#	check for left recursion
# ends program if invalid
def isGrammarValid (grammarDescription: dict, nonterminals: list) -> None:
	targetRule = "S0"

	if not targetRule in grammarDescription:
		print("[Error] S0 starting rule not present in grammar!")
		exit()

	productions = grammarDescription[targetRule]

	if len(productions) > 1:
		print("[Error] Starting symbol S0 can't have more than one production!")
		exit()

	prod = productions[0]

	if len(prod) > 1 or prod[0] not in nonterminals:
		print("[Error] Starting symbol S0 must lead ONLY to a SINGLE NONTERMINAL!")
		exit()

	return

def removeUnreachableRules (grammarDescription: dict, nonterminals: list) -> None:
	reachedNonterminals = [ "S0" ]

	initialSymbol = grammarDescription["S0"][0][0]

	stack = [ initialSymbol ]

	while len(stack):
		currentSymbol: str = stack.pop()
		reachedNonterminals.append(currentSymbol)

		# all symbols in the productions generated by currentSymbol
		symbols = [ s for prod in grammarDescription[currentSymbol] for s in prod ]

		for symbol in symbols:
			if symbol in stack or symbol in reachedNonterminals:
				continue
			if symbol in nonterminals:
				stack.append(symbol)

	unreachableNonterminals = []
	for k in grammarDescription:
		if k in reachedNonterminals:
			continue

		print(f"WARNING: Symbol {k} is never reached and will be removed from grammar!")
		unreachableNonterminals.append(k)

	for k in unreachableNonterminals:
		nonterminals.pop(nonterminals.index(k))
		del grammarDescription[k]

	return

# doesn't support left recursive grammars
def genSetFIRST (grammarDescription: dict, terminals: list) -> dict:
	FIRST: dict = {}

	for s in terminals:
		FIRST[s] = set([s])

	stack: list = [ "S0" ]

	while len(stack):
		curr: str = stack[-1]
		FIRST[curr] = set()

		firstSymbols = set([prod[0] for prod in grammarDescription[curr]])

		# set to true if we need to unite our FIRST set
		# with another nonterminal that hasn't been calculated yet
		# then we skip our turn and finish later when it's available
		skip = False
		for s in firstSymbols:
			if s in terminals or s in FIRST:
				FIRST[curr] = FIRST[curr].union(FIRST[s])
			elif s != curr:
				stack.append(s)
				skip = True
				break

		if not skip:
			stack.pop()

	return FIRST

def generateInitialTable (grammarDescription: dict, grammarRules: list, terminals: list, nonterminals: list, FIRST: dict) -> RuleGroupClass:
	thisGroup = RuleGroupClass()

	# start with S0 rule with EOF lookahead
	S0Prod = grammarDescription["S0"][0]
	S0Index = findIdOfProduction(grammarRules, "S0", S0Prod)
	S0Rule = RuleClass(S0Index, "S0", S0Prod, 0, "EOF")
	thisGroup.addRule(S0Rule)

	fillWithRemainingRules(grammarDescription, grammarRules, thisGroup, nonterminals, FIRST)

	return thisGroup

def findIdOfProduction (rules: list, symbol: str, production: list) -> int:
	for r in rules:
		if r.symbol != symbol:
			continue

		if production == r.production:
			return r.id

	return -1

def fillWithRemainingRules (grammar: dict, grammarRules: list, group: RuleGroupClass, nonterminals: list, FIRST: dict) -> None:
	# get all expected nonterminals
	# for each rule that expects a nonterminal:
	# get productions of that nonterminal
	# turn all of them into rules with cursor at 0
	# with the same lookAhead as the rule that expected the nonterminal
	# repeat this process for the added rules

	rules = group.rules

	i = 0
	while i < len(rules):
		currRule = rules[i]
		i += 1

		expecting = currRule.expecting()

		# if symbol ahead of cursor isn't nonterminal, ignore
		if expecting not in nonterminals:
			continue

		# for each production the nonterminal has
		for prod in grammar[expecting]:
			lookAheads = []

			nextExpected = currRule.nextExpected()

			# cursor at end, lookAheads is the same as rule that originated it
			if nextExpected == None:
				lookAheads = list(currRule.lookAheads)
			elif nextExpected in nonterminals:
				for l in FIRST[nextExpected]:
					lookAheads.append(l)
			# is terminal
			else:
				lookAheads.append(nextExpected)

			# find correct ID here
			correctId = findIdOfProduction(grammarRules, expecting, prod)

			newRule = RuleClass(correctId, expecting, prod, 0, lookAheads)

			if correctId == -1:
				print(newRule.prettyPrint())

			# try to find similar rule to union lookaheads
			# similar is same symbol, same prod, same cursor
			# lookAheads may differ but we'll merge them
			found = False
			for j in range(len(rules)):
				otherRule = rules[j]
				if newRule.isSimilarTo(otherRule):
					# merging lookaheads
					otherRule.lookAheads = otherRule.lookAheads.union(lookAheads)
					found = True
					break # exit for

			# found similar, no need to add this rule to list
			if found:
				continue

			group.addRule(newRule)

	return

def getGrammarRules (grammar: dict,  terminals: list, nonterminals: list) -> list:
	rules = []

	for k, v in grammar.items():
		for prod in v:
			rule = RuleClass(len(rules), k, prod, 0, "EOF")

			if rule not in rules:
				rules.append(rule)

	return rules

def getRuleN (grammarRules: list, n: int) -> str:
	rule = grammarRules[n]

	return rule.symbol

def getRuleNSize (grammarRules: list, n: int) -> int:
	rule = grammarRules[n]

	return len(rule.production)
